{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AsyncResult","text":"<p>AsyncResult is a small Kotlin Multiplatform library to model asynchronous operations using a sealed hierarchy. It captures the common states you deal with in UI and data layers:</p> <ul> <li><code>NotStarted</code> - The operation hasn't begun yet</li> <li><code>Loading</code> - The operation is in progress</li> <li><code>Success</code> - The operation completed successfully with a value</li> <li><code>Error</code> - The operation failed, optionally with a throwable and metadata</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Convert any <code>Flow</code> to an <code>AsyncResult</code> flow and handle all states:</p> <pre><code>userRepository.observeUser()\n    .asAsyncResult()\n    .collect { result -&gt;\n        when (result) {\n            is NotStarted -&gt; { /* Initial state */ }\n            is Loading -&gt; showLoading()\n            is Success -&gt; showUser(result.value)\n            is Error -&gt; showError(result.throwable)\n        }\n    }\n</code></pre> <p>The library provides a rich set of operators for transforming, combining, and extracting values from these states, making it easy to handle async operations in a type-safe way.</p>"},{"location":"#modules","title":"Modules","text":""},{"location":"#asyncresult-core","title":"asyncresult (Core)","text":"<p>The core module contains the type hierarchy and all essential utilities:</p> <ul> <li>Transformations - <code>mapSuccess</code>, <code>mapError</code>, <code>flatMap</code>, <code>fold</code>, <code>orError</code>, <code>filterOrError</code>, <code>castOrError</code></li> <li>Monad comprehension DSL - <code>result { }</code>, <code>bind()</code>, <code>ensure()</code>, <code>ensureNotNull()</code>, <code>error()</code>, <code>loading()</code></li> <li>Value extraction - <code>getOrNull</code>, <code>getOrDefault</code>, <code>getOrElse</code>, <code>getOrThrow</code>, <code>getOrEmpty</code></li> <li>Side effects - <code>onSuccess</code>, <code>onLoading</code>, <code>onError</code>, <code>onNotStarted</code></li> <li>Unwrapping - <code>unwrap</code>, <code>unwrapError</code>, <code>expect</code>, <code>expectError</code> (Rust-style extraction)</li> <li>Combining - <code>zip</code>, <code>zipWith</code>, <code>and</code>, <code>andThen</code>, <code>spread</code></li> <li>Flow helpers - <code>asAsyncResult</code>, <code>onLoading</code>, <code>onSuccess</code>, <code>onError</code>, <code>skipWhileLoading</code>, <code>cacheLatestSuccess</code>, <code>timeoutToError</code>, <code>retryOnError</code></li> <li>Collection utilities - <code>getAllErrors</code>, <code>anyLoading</code>, <code>anyIncomplete</code></li> </ul> <p>View full documentation</p>"},{"location":"#asyncresult-either","title":"asyncresult-either","text":"<p>Extensions for interoperability with Arrow's <code>Either</code> type:</p> <ul> <li>Conversion - <code>toAsyncResult()</code> to convert <code>Either</code> to <code>AsyncResult</code></li> <li>Binding - <code>bind()</code> to flatten <code>AsyncResult&lt;Either&lt;L, R&gt;&gt;</code> to <code>AsyncResult&lt;R&gt;</code></li> <li>Flow conversion - <code>asAsyncResult()</code> to convert <code>Flow&lt;Either&lt;L, R&gt;&gt;</code> to <code>Flow&lt;AsyncResult&lt;R&gt;&gt;</code>, <code>toEither()</code> to convert <code>Flow&lt;AsyncResult&lt;T&gt;&gt;</code> to <code>Either</code></li> </ul> <p>View full documentation</p>"},{"location":"#asyncresult-test","title":"asyncresult-test","text":"<p>Testing utilities built on assertk:</p> <ul> <li>State assertions - <code>isNotStarted()</code>, <code>isLoading()</code>, <code>isIncomplete()</code>, <code>isSuccess()</code>, <code>isError()</code></li> <li>Value assertions - <code>isSuccessEqualTo()</code>, <code>isErrorWithMetadata()</code>, <code>isErrorWithMetadataEqualTo()</code></li> <li>Flow assertions - <code>assertSuccess()</code>, <code>assertError()</code> for testing flow emissions</li> </ul> <p>View full documentation</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(\"io.nlopez.asyncresult:asyncresult:&lt;version&gt;\")\n\n    // Optional: Arrow Either interop\n    implementation(\"io.nlopez.asyncresult:asyncresult-either:&lt;version&gt;\")\n\n    // Optional: Testing helpers\n    testImplementation(\"io.nlopez.asyncresult:asyncresult-test:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"core/","title":"Core API","text":"<p>The <code>asyncresult</code> artifact contains the core types and utilities for modeling asynchronous operations.</p>"},{"location":"core/#types","title":"Types","text":"<p>The library provides a sealed class hierarchy to represent the different states:</p> <ul> <li><code>NotStarted</code> - Idle state before an operation begins. Useful for user-initiated actions that haven't started yet.</li> <li><code>Loading</code> - The operation is in-flight.</li> <li><code>Success&lt;T&gt;</code> - The operation completed successfully, containing the result value.</li> <li><code>Error</code> - The operation failed. Can optionally contain a <code>Throwable</code> and typed metadata for context.</li> <li><code>Incomplete</code> - A marker interface implemented by both <code>NotStarted</code> and <code>Loading</code>, useful for bundling them in exhaustive <code>when</code> statements.</li> </ul> <pre><code>val result: AsyncResult&lt;User&gt; = Loading\n</code></pre>"},{"location":"core/#transforming-values","title":"Transforming values","text":""},{"location":"core/#mapping","title":"Mapping","text":"<p>Transform the success value while preserving the result state:</p> <pre><code>val userName: AsyncResult&lt;String&gt; = userResult.mapSuccess { it.name }\n</code></pre> <p>Transform errors:</p> <pre><code>val enrichedResult = result.mapError { error -&gt; \n    error.withMetadata(NetworkFailure) \n}\n</code></pre>"},{"location":"core/#folding","title":"Folding","text":"<p>Generate a value from any state:</p> <pre><code>val message = result.fold(\n    ifNotStarted = { \"Waiting\" },\n    ifLoading = { \"Loading...\" },\n    ifSuccess = { \"Hello ${it.name}\" },\n    ifError = { \"Error: ${it.throwable?.message}\" },\n)\n</code></pre>"},{"location":"core/#flatmap-and-chaining","title":"FlatMap and chaining","text":"<p>Chain operations that return <code>AsyncResult</code>:</p> <pre><code>val profile: AsyncResult&lt;Profile&gt; = userResult.flatMap { user -&gt;\n    fetchProfile(user.id)\n}\n</code></pre> <p>Use <code>andThen</code> for explicit chaining:</p> <pre><code>val result = fetchUser().andThen { user -&gt; \n    fetchPermissions(user.id) \n}\n</code></pre>"},{"location":"core/#filtering-and-casting","title":"Filtering and casting","text":"<p>Filter values or convert to errors:</p> <pre><code>val admin: AsyncResult&lt;User&gt; = userResult.filterOrError { it.isAdmin }\nval typed: AsyncResult&lt;Admin&gt; = result.castOrError&lt;Admin&gt;()\n</code></pre> <p>Handle nullable values:</p> <pre><code>val nonNull: AsyncResult&lt;User&gt; = nullableResult.orError()\n</code></pre>"},{"location":"core/#getting-values","title":"Getting values","text":"<p>Extract the underlying value in different ways:</p> <pre><code>val value: User? = result.getOrNull()\nval value: User = result.getOrDefault(defaultUser)\nval value: User = result.getOrElse { fallbackUser }\nval value: User = result.getOrThrow() // throws if not Success\n\n// For collections\nval items: List&lt;Item&gt; = listResult.getOrEmpty()\n</code></pre> <p>Extract error information:</p> <pre><code>val error: Error? = result.errorOrNull()\nval throwable: Throwable? = result.throwableOrNull()\nval metadata: MyError? = result.errorWithMetadataOrNull&lt;MyError&gt;()\n</code></pre>"},{"location":"core/#side-effects","title":"Side effects","text":"<p>Run code based on the current state:</p> <pre><code>result\n    .onNotStarted { showPlaceholder() }\n    .onLoading { showSpinner() }\n    .onSuccess { user -&gt; render(user) }\n    .onError { showError(it) }\n    .onErrorWithMetadata&lt;R, NetworkError&gt; { throwable, metadata -&gt; \n        showNetworkError(metadata) \n    }\n</code></pre>"},{"location":"core/#unwrapping-rust-style","title":"Unwrapping (Rust-style)","text":"<p>For when you're certain about the state and want to extract values directly:</p> <pre><code>val user: User = result.unwrap() // throws UnwrapException if not Success\nval error: Error = result.unwrapError()\nval throwable: Throwable = result.unwrapThrowable()\nval metadata: MyError = result.unwrapMetadata&lt;MyError&gt;()\n</code></pre> <p>With custom error messages:</p> <pre><code>val user = result.expect { \"User should be loaded by now\" }\nval error = result.expectError { \"Expected failure\" }\n</code></pre>"},{"location":"core/#monad-comprehension-dsl-result","title":"Monad comprehension DSL: <code>result { ... }</code>","text":"<p>AsyncResult includes an inline comprehension DSL inspired by Arrow Raise. It lets you write sequential code and short-circuit on the first non-success state.</p> <pre><code>val userSummary: AsyncResult&lt;String&gt; = result {\n    val user = fetchUser().bind()\n    val permissions = fetchPermissions(user.id).bind()\n\n    ensure(permissions.canViewProfile) { IllegalStateException(\"Unauthorized\") }\n\n    \"${user.name} (${permissions.role})\"\n}\n</code></pre>"},{"location":"core/#dsl-primitives","title":"DSL primitives","text":"<p>Inside <code>result {}</code> you can use:</p> <ul> <li><code>bind()</code> - Extracts from <code>Success</code>, short-circuits on <code>Error</code>, <code>Loading</code>, or <code>NotStarted</code></li> <li><code>error(Throwable)</code> - Short-circuits with <code>Error</code></li> <li><code>loading()</code> - Short-circuits with <code>Loading</code></li> <li><code>ensure(condition) { throwable }</code> - Validates a condition or short-circuits with <code>Error</code></li> <li><code>ensureNotNull(value) { throwable }</code> - Validates nullability or short-circuits with <code>Error</code></li> </ul>"},{"location":"core/#why-inline-not-suspend","title":"Why <code>inline</code> (not <code>suspend</code>)","text":"<p>The builder is intentionally <code>inline</code> and not <code>suspend</code> so it works in both contexts:</p> <ul> <li>In non-suspend code, you get regular synchronous composition</li> <li>In suspend code, the inlined block inherits the caller's suspend context automatically</li> </ul> <pre><code>// Non-suspend usage\nval parsed = result { parse(input).bind() }\n\n// Suspend usage\nsuspend fun load(): AsyncResult&lt;Data&gt; = result {\n    val token = loadToken().bind()\n    api.fetch(token).bind()\n}\n</code></pre>"},{"location":"core/#combining-results","title":"Combining results","text":""},{"location":"core/#zipping","title":"Zipping","text":"<p>Combine multiple results into one:</p> <pre><code>val combined = zip(\n    { userResult }, \n    { permissionsResult }\n) { user, permissions -&gt;\n    UserWithPermissions(user, permissions)\n}\n</code></pre> <p>Or using the <code>zipWith</code> extension:</p> <pre><code>val combined = userResult.zipWith(permissionsResult) { user, permissions -&gt;\n    UserWithPermissions(user, permissions)\n}\n</code></pre> <p>Supports up to 4 results.</p>"},{"location":"core/#spreading","title":"Spreading","text":"<p>Split a result containing a <code>Pair</code> or <code>Triple</code>:</p> <pre><code>val (userResult, settingsResult) = pairResult.spread()\n</code></pre>"},{"location":"core/#working-with-collections","title":"Working with collections","text":"<p>Utilities for handling multiple results:</p> <pre><code>val results: List&lt;AsyncResult&lt;*&gt;&gt; = listOf(result1, result2, result3)\n\nval errors: List&lt;Error&gt; = results.getAllErrors()\nval throwables: List&lt;Throwable&gt; = results.throwables()\nval incompletes: List&lt;Incomplete&gt; = results.incompletes()\nval isAnyLoading: Boolean = results.anyLoading()\nval isAnyIncomplete: Boolean = results.anyIncomplete()\n</code></pre> <p>Standalone functions:</p> <pre><code>val hasError = anyError(result1, result2, result3)\nval hasLoading = anyLoading(result1, result2, result3)\nval errors = errorsFrom(result1, result2, result3)\n</code></pre>"},{"location":"core/#flow-helpers","title":"Flow helpers","text":""},{"location":"core/#converting-to-asyncresult","title":"Converting to AsyncResult","text":"<p>Transform a regular <code>Flow&lt;T&gt;</code> into <code>Flow&lt;AsyncResult&lt;T&gt;&gt;</code>:</p> <pre><code>// Basic conversion with automatic loading state\nflowOf(1, 2, 3)\n    .asAsyncResult()\n    .collect { result -&gt;\n        // Emits: Loading, Success(1), Success(2), Success(3)\n    }\n\n// Without initial loading state\nfetchDataFlow()\n    .asAsyncResult(startWithLoading = false)\n    .collect { result -&gt;\n        // Emits: Success(data1), Success(data2), ...\n    }\n\n// Errors are automatically wrapped\nflow {\n    emit(42)\n    throw IOException(\"Network error\")\n}.asAsyncResult()\n    .collect { result -&gt;\n        // Emits: Loading, Success(42), Error(IOException)\n    }\n</code></pre> <p>The <code>asAsyncResult()</code> extension: - Wraps each emitted value in <code>Success</code> - Catches exceptions (except <code>CancellationException</code>) and wraps them in <code>Error</code> - Optionally starts with a <code>Loading</code> emission (default: <code>true</code>) - Preserves coroutine cancellation by rethrowing <code>CancellationException</code></p>"},{"location":"core/#side-effects_1","title":"Side effects","text":"<p>Extensions for <code>Flow&lt;AsyncResult&lt;T&gt;&gt;</code>:</p> <pre><code>flowOf(result)\n    .onLoading { showSpinner() }\n    .onSuccess { render(it) }\n    .onError { showError(it) }\n</code></pre> <p>Extract values from flows:</p> <pre><code>val value: User = flow.getOrThrow()\nval value: User? = flow.getOrNull()\nval value: User = flow.getOrElse { fallbackUser }\n</code></pre>"},{"location":"core/#filtering","title":"Filtering","text":"<p>Skip loading states entirely:</p> <pre><code>flow.skipWhileLoading()\n    .collect { result -&gt;\n        // Only receives NotStarted, Success, or Error\n    }\n\n// Alias\nflow.filterNotLoading()\n</code></pre>"},{"location":"core/#caching","title":"Caching","text":"<p>Cache the latest success value and emit it during reloads:</p> <pre><code>flow.cacheLatestSuccess()\n    .collect { result -&gt;\n        // During reload: shows cached Success instead of Loading\n    }\n</code></pre> <p>This is useful for \"stale-while-revalidate\" patterns where you want to show existing data while fetching updates.</p>"},{"location":"core/#timeout","title":"Timeout","text":"<p>Convert slow operations to errors:</p> <pre><code>flow.timeoutToError(5.seconds) { \n    TimeoutException(\"Request timed out\") \n}\n</code></pre> <p>If no <code>Success</code> or <code>Error</code> is emitted within the timeout, an <code>Error</code> with the provided throwable is emitted.</p>"},{"location":"core/#retry","title":"Retry","text":"<p>Automatically retry on errors:</p> <pre><code>flow.retryOnError(\n    maxRetries = 3,\n    delay = 1.seconds,\n    predicate = { error -&gt; \n        error.throwable is IOException  // Only retry network errors\n    }\n)\n</code></pre> <p>The flow will restart from the beginning on each retry attempt.</p>"},{"location":"either/","title":"Arrow Either extensions","text":"<p>The <code>asyncresult-either</code> artifact provides helpers to bridge Arrow's <code>Either</code> type with <code>AsyncResult</code>. This is useful when working with codebases that use Arrow for error handling.</p>"},{"location":"either/#converting-floweither-to-flowasyncresult","title":"Converting Flow&lt;Either&gt; to Flow&lt;AsyncResult&gt;","text":"<p>Transform a <code>Flow&lt;Either&lt;L, R&gt;&gt;</code> into a <code>Flow&lt;AsyncResult&lt;R&gt;&gt;</code>:</p> <pre><code>val userFlow: Flow&lt;Either&lt;UserError, User&gt;&gt; = userRepository.observeUser()\n\nuserFlow.asAsyncResult()\n    .collect { result -&gt;\n        when (result) {\n            is Loading -&gt; showLoading()\n            is Success -&gt; showUser(result.value)\n            is Error -&gt; {\n                val userError = result.metadataOrNull&lt;UserError&gt;()\n                showError(userError)\n            }\n            is NotStarted -&gt; { }\n        }\n    }\n</code></pre> <p>The conversion works as follows: - <code>Either.Right</code> becomes <code>Success</code> - <code>Either.Left</code> becomes <code>Error</code> with the left value stored in metadata - Optionally starts with <code>Loading</code> (default: <code>true</code>)</p> <pre><code>// Without initial loading state\nuserFlow.asAsyncResult(startWithLoading = false)\n</code></pre>"},{"location":"either/#special-handling-for-throwable","title":"Special handling for Throwable","text":"<p>When the left type is <code>Throwable</code>, it's stored in <code>Error.throwable</code> instead of metadata:</p> <pre><code>val dataFlow: Flow&lt;Either&lt;IOException, Data&gt;&gt; = fetchData()\n\ndataFlow.asAsyncResult()\n    .collect { result -&gt;\n        when (result) {\n            is Error -&gt; showError(result.throwable) // IOException is here\n            is Success -&gt; showData(result.value)\n            else -&gt; { }\n        }\n    }\n</code></pre>"},{"location":"either/#converting-either-to-asyncresult","title":"Converting Either to AsyncResult","text":"<p>Transform an <code>Either&lt;L, R&gt;</code> directly into an <code>AsyncResult&lt;R&gt;</code>:</p> <pre><code>val either: Either&lt;Failure, User&gt; = fetchUser()\nval result: AsyncResult&lt;User&gt; = either.toAsyncResult()\n</code></pre> <ul> <li><code>Either.Right</code> becomes <code>Success</code></li> <li><code>Either.Left</code> becomes <code>Error</code> with the left value stored in metadata</li> </ul>"},{"location":"either/#binding-nested-either-values","title":"Binding nested Either values","text":"<p>When you have an <code>AsyncResult</code> containing an <code>Either</code>, use <code>bind()</code> to flatten it:</p> <pre><code>val result: AsyncResult&lt;Either&lt;Failure, User&gt;&gt; = Success(userEither)\nval unwrapped: AsyncResult&lt;User&gt; = result.bind()\n</code></pre> <p>The <code>bind()</code> function handles the conversion:</p> <ul> <li><code>Success(Right(value))</code> becomes <code>Success(value)</code></li> <li><code>Success(Left(error))</code> becomes <code>Error</code> with the left value in metadata</li> <li><code>Loading</code>, <code>NotStarted</code>, and <code>Error</code> pass through unchanged</li> </ul>"},{"location":"either/#special-handling-for-throwable_1","title":"Special handling for Throwable","text":"<p>When the left type is <code>Throwable</code>, it's stored in <code>Error.throwable</code> instead of metadata:</p> <pre><code>val result: AsyncResult&lt;Either&lt;Throwable, User&gt;&gt; = Success(Left(IOException()))\nval bound: AsyncResult&lt;User&gt; = result.bind() // Error with throwable set\n</code></pre>"},{"location":"either/#raise-interop","title":"Raise interop","text":"<p>If you're using Arrow's Raise DSL, you can bind an <code>AsyncResult&lt;T&gt;</code> directly in a <code>Raise&lt;Error&gt;</code> context:</p> <pre><code>import arrow.core.raise.either\n\nval either = either&lt;Error, User&gt; {\n    repository.getUser().bind()\n}\n</code></pre> <p>Behavior: - <code>Success(value)</code> returns <code>value</code> - <code>Error</code> raises that same error - <code>Loading</code> and <code>NotStarted</code> raise an <code>Error</code> with the state stored in metadata</p>"},{"location":"either/#converting-flow-to-either","title":"Converting Flow to Either","text":"<p>Transform a <code>Flow&lt;AsyncResult&lt;R&gt;&gt;</code> into an <code>Either</code>:</p> <pre><code>val flow: Flow&lt;AsyncResult&lt;User&gt;&gt; = userFlow\nval either: Either&lt;Error, User&gt; = flow.toEither()\n</code></pre> <p>This waits for the first terminal emission (<code>Success</code> or <code>Error</code>) and converts it:</p> <ul> <li><code>Success</code> becomes <code>Either.Right</code></li> <li><code>Error</code> becomes <code>Either.Left</code></li> </ul>"},{"location":"either/#custom-error-transformation","title":"Custom error transformation","text":"<p>If you need a specific error type, provide a transform function:</p> <pre><code>val either: Either&lt;NetworkError, User&gt; = flow.toEither { error -&gt;\n    error.metadataOrNull&lt;NetworkError&gt;() ?: NetworkError.Unknown\n}\n</code></pre> <p>By default, it attempts to extract the error type from the <code>Error.metadata</code>.</p>"},{"location":"testing/","title":"Testing","text":"<p>The <code>asyncresult-test</code> artifact provides assertk extensions for testing <code>AsyncResult</code> values in a fluent and readable way.</p>"},{"location":"testing/#state-assertions","title":"State assertions","text":"<p>Assert that a result is in a specific state:</p> <pre><code>import assertk.assertThat\nimport io.nlopez.asyncresult.test.*\n\nassertThat(result).isNotStarted()\nassertThat(result).isLoading()\nassertThat(result).isIncomplete()  // NotStarted or Loading\nassertThat(result).isSuccess()\nassertThat(result).isError()\n</code></pre>"},{"location":"testing/#success-assertions","title":"Success assertions","text":"<p>Assert success with a specific value:</p> <pre><code>val result: AsyncResult&lt;Int&gt; = Success(42)\nassertThat(result).isSuccessEqualTo(42)\n</code></pre> <p>Chain assertions on the success value:</p> <pre><code>assertThat(result).isSuccess().isEqualTo(expectedUser)\nassertThat(result).isSuccess().prop(User::name).isEqualTo(\"Alice\")\n</code></pre>"},{"location":"testing/#error-assertions","title":"Error assertions","text":"<p>Assert error state and inspect the error:</p> <pre><code>assertThat(result).isError()\n\n// Check the throwable\nassertThat(result).isError().isThrowableEqualTo(expectedException)\n\n// Check metadata\nassertThat(result).isErrorWithMetadata&lt;T, NetworkError&gt;()\nassertThat(result).isErrorWithMetadataEqualTo(NetworkError.Timeout)\n\n// Chain assertions on metadata\nassertThat(result).isError().isMetadataEqualTo(expectedMetadata)\n</code></pre>"},{"location":"testing/#flow-assertions","title":"Flow assertions","text":"<p>Test terminal emissions from a <code>Flow&lt;AsyncResult&lt;T&gt;&gt;</code>:</p> <pre><code>// Assert the first terminal emission is Success with value\nflow.assertSuccess(42)\n\n// Assert the first terminal emission is Error and get it for further checks\nval error: Error = flow.assertError()\nassertThat(error.throwable).isInstanceOf(IOException::class)\n</code></pre> <p>These suspend functions wait for the first <code>Success</code> or <code>Error</code> emission, ignoring <code>Loading</code> and <code>NotStarted</code> states.</p>"}]}